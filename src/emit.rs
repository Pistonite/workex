use std::collections::BTreeMap;
use std::path::Path;

use codize::{cblock, cconcat, Concat};
use error_stack::{Result, ResultExt};

use crate::{Interface, Package};

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("IO error")]
    IO,
}

fn header() -> Concat {
    cconcat![
        "/**",
        " * This file is generated by workex",
        " *",
        " * DO NOT EDIT",
        " */",
        "/* eslint-disable */",
    ]
}

/// Emit the output
pub fn emit(pkg: &Package) -> Result<(), Error> {
    let out_dir = &pkg.out_dir;

    emit_sdk(pkg)?;
    let func_map = make_protocol(pkg);
    emit_index(pkg, out_dir)?;

    for interface in &pkg.interfaces {
        emit_interface_send(interface, &func_map, out_dir, &pkg.protocol)?;
        emit_interface_recv(interface, &func_map, out_dir, &pkg.protocol, &pkg.lib_path)?;
    }

    Ok(())
}

macro_rules! emit_sdk_file {
    ($out_dir:ident, $file:literal) => {{
        let out_path = $out_dir.join($file);
        let mut output: String = header().to_string();
        output.push_str(include_str!(concat!("../lib/", $file)));
        write_file(&out_path, output)
    }};
}

/// Emit workex library
fn emit_sdk(pkg: &Package) -> Result<(), Error> {
    let lib_path = Path::new(&pkg.out_dir).join(&pkg.lib_path);

    if lib_path.exists() {
        std::fs::remove_dir_all(&lib_path).change_context(Error::IO)?;
    }
    std::fs::create_dir_all(&lib_path).change_context(Error::IO)?;
    emit_sdk_file!(lib_path, "index.ts")?;
    emit_sdk_file!(lib_path, "bind.ts")?;
    emit_sdk_file!(lib_path, "client.ts")?;
    emit_sdk_file!(lib_path, "types.ts")?;
    emit_sdk_file!(lib_path, "utils.ts")?;
    emit_sdk_file!(lib_path, "adapters.ts")?;

    Ok(())
}

/// Emit protocol.ts
fn make_protocol(pkg: &Package) -> BTreeMap<String, usize> {
    pkg.interfaces
        .iter()
        .flat_map(|interface| {
            interface
                .functions
                .iter()
                .map(|function| (&interface.name, &function.name))
        })
        .enumerate()
        .map(|(i, (interface, function))| {
            (format!("{interface}_{function}"), i + 16) // offset the id to reserve some for the SDK
        })
        .collect()
}

/// Emit send.ts and recv.ts
fn emit_index(pkg: &Package, out_dir: &Path) -> Result<(), Error> {
    for id in ["send", "recv"] {
        let output = cconcat![
            header(),
            cconcat!(pkg.interfaces.iter().map(|interface| {
                format!(r#"export * from "./{}.{}.ts";"#, interface.name, id)
            }))
        ];
        let path = out_dir.join(format!("{id}.ts"));
        write_file(&path, output.to_string())?;
    }

    Ok(())
}

fn emit_interface_send(
    interface: &Interface,
    func_map: &BTreeMap<String, usize>,
    out_dir: &Path,
    protocol: &str,
) -> Result<(), Error> {
    let imports = &interface.imports.send;

    let class_decl = cblock! {
        format!("export class {0}Client implements {0} {{", interface.name),
        [
            format!("private client: {}<\"{protocol}\">", imports.workex_client_ident),
            "",
            cblock! {
                format!("constructor(options: {}) {{", imports.workex_client_options_ident),
                [
                    format!("this.client = new {}(\"{protocol}\", options);", imports.workex_client_ident)
                ],
                "}"
            },
            cconcat!(interface.functions.iter().map(|f| {
                let func_ident = format!("{}_{}", interface.name, f.name);
                let funcid_expr = format!("{} /* {}.{} */", func_map.get(&func_ident).unwrap(), interface.name, f.name);
                f.to_send_function(&funcid_expr, &imports.workex_promise_ident)
            })),
            "",
            "/**",
            " * Terminate the client and the underlying worker",
            " *",
            " * This method is generated by workex",
            " */",
            cblock! {
                "public terminate() {",
                [
                    "this.client.terminate();"
                ],
                "}"
            }
        ],
        "}"
    };

    let output = cconcat![
        header(),
        format!(
            "import type {{ {} }} from \"./{}\";",
            interface.name, interface.filename
        ),
        "",
        cconcat!(imports.imports.iter().map(|import| import.to_code())),
        "",
        interface.comment.to_code(),
        class_decl
    ];

    let path = out_dir.join(format!("{}.send.ts", interface.name));
    write_file(&path, output.to_string())?;

    Ok(())
}

fn emit_interface_recv(
    interface: &Interface,
    func_map: &BTreeMap<String, usize>,
    out_dir: &Path,
    protocol: &str,
    lib_path: &str,
) -> Result<(), Error> {
    let bind_func = cblock! {
        format!("export function bind{0}Host(delegate: {0}, options: WorkexBindOptions) {{", interface.name),
        [
            cblock! {
                format!("bindHost(\"{protocol}\", options, (fId: number, _payload: any[]) => {{"),
                [
                    cblock! {
                        "switch (fId) {",
                        interface.functions.iter().map(|f| {
                let func_ident = format!("{}_{}", interface.name, f.name);
                let funcid_expr = format!("{} /* {}.{} */", func_map.get(&func_ident).unwrap(), interface.name, f.name);
                            f.to_recv_case(&funcid_expr, "delegate", "_payload")
                        }),
                        "}"
                    },
                    "return undefined;"
                ],
                "});"
            }
        ],
        "}"
    };

    let output = cconcat![
        header(),
        format!("import {{ type WorkexBindOptions, bindHost }} from \"{lib_path}\";"),
        format!(
            "import type {{ {} }} from \"./{}\";",
            interface.name, interface.filename
        ),
        "",
        bind_func
    ];

    let path = out_dir.join(format!("{}.recv.ts", interface.name));
    write_file(&path, output.to_string())?;

    Ok(())
}

fn write_file<T: AsRef<str>>(path: &Path, code: T) -> Result<(), Error> {
    std::fs::write(path, code.as_ref())
        .change_context(Error::IO)
        .attach_printable(format!("Failed to write {}", path.display()))?;

    Ok(())
}
